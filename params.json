{"name":"SoS","tagline":"Script of Scripts, a lightweight workflow system for the creation of readable pipelines","body":"<!-- START doctoc generated TOC please keep comment here to allow auto update -->\r\n<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\r\n**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*\r\n\r\n- [Design of SoS](#design-of-sos)\r\n- [Tutorial](#tutorial)\r\n  - [Organize your scripts as a SoS script](#organize-your-scripts-as-a-sos-script)\r\n  - [Make the script work for other input files](#make-the-script-work-for-other-input-files)\r\n  - [Ignore steps that do not need to be rerun](#ignore-steps-that-do-not-need-to-be-rerun)\r\n  - [Execute steps in parallel](#execute-steps-in-parallel)\r\n- [Unique features and limitations](#unique-features-and-limitations)\r\n- [Summary](#summary)\r\n\r\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\r\n\r\n**Script of Scripts (SoS)** is a lightweight workflow system that helps you oraganize your commands and scripts in different languages into readable workflows that can be easily understood and modified by others. It is an easy-to-use alternative to specialized workflow systems such as [CWL](http://common-workflow-language.github.io/draft-3/) which makes it an ideal tool for the creation and maintainance of workflows that need to be frequently updated and shared with others. \r\n\r\n## Design of SoS\r\nThe core of SoS has mostly been implemented in another project but we are re-designing and re-implementing it to make SoS more user-friendly and powerful. Your involvement and suggestions are very welcome.\r\n\r\n* [User interface](doc/commandline.md)\r\n* [Format specification](doc/sos_format_v1.md)\r\n* [Workflow actions](doc/actions.md)\r\n* [Implementation details](doc/implementation.md)\r\n* [Examples](doc/examples.md)\r\n* [Pending problems](doc/problems.md)\r\n \r\n\r\n## Tutorial\r\n\r\nA SoS script consists of one or more scripts, comments and optional SoS directives. In its simplest form, a sos script is simply a series of scripts that can be executed sequentially by different intepreters.\r\n\r\nLet us assume that you are a bioinformaticist needed to compare the expression levels between two samples. After reading some online tutorials, you ended up with some working commands\r\n\r\n```bash\r\n# index reference genome\r\nSTAR --runMode genomeGenerate --genomeFastaFile human38.fasta --genomeDir STAR_index\r\n# align reads to the reference genome\r\nSTAR --genomeDir STAR_index --outSAMtype BAM SortedByCoordinate --readFilesIn control.fasta \\\r\n    --quantMode GeneCounts --outFileNamePrefix aligned/control\r\nSTAR --genomeDir STAR_index --outSAMtype BAM SortedByCoordinate --readFilesIn mutated.fasta \\\r\n    --quantMode GeneCounts --outFileNamePrefix aligned/mutated\r\n```\r\n\r\nThe first command builds an index of the reference genome in prepration for the latter steps, the second command aligns reads from the first sample to the reference genome, and the third command aligns reads from the second sample to the reference genome. Do not panic if you do not know what these commands are doing, this is just an example.\r\n\r\nThese commands generate, among other files, two files named ``aligned/control.out.tab`` and ``aligned/mutated.out.tab`` with expression counts of all genes. You then wrote a [R](https://www.r-project.org/) script to analyze the results, something like\r\n\r\n```R\r\ncontrol.count <- read.table('aligned/control.out.tab')\r\nmutated.count <- read.table('aligned/mutated.out.tab')\r\n# normalize, compare, output etc, ignored.\r\npdf('myfigure.pdf')\r\n# plot results\r\ndev.off()\r\n```\r\n\r\n### Organize your scripts as a SoS script\r\nThe project completed successfully and you needed to archive the scripts for later reference. Instead of having two files lying around with perhaps another ``README`` file to describe what you have done, you can write a single SoS script named ``myanalysis.sos`` with content\r\n\r\n```python\r\n#!/usr/bin/env sos-runner\r\n#fileformat=SOS1.0\r\n\r\n# This script aligns raw reads of a control and a mutated sample \r\n# to the reference genome and compare the expression values\r\n# of the samples at genes A, B and C.\r\n\r\n[1]\r\n# index reference genome\r\nrun('''\r\nSTAR --runMode genomeGenerate --genomeFastaFile human38.fasta --genomeDir STAR_index\r\n''')\r\n    \r\n[2]\r\n# align reads to the reference genome\r\nrun('''\r\nSTAR --genomeDir STAR_index --outSAMtype BAM SortedByCoordinate  --readFilesIn control.fasta \\\r\n    --quantMode GeneCounts --outFileNamePrefix aligned/control\r\nSTAR --genomeDir STAR_index --outSAMtype BAM SortedByCoordinate --readFilesIn mutated.fasta \\\r\n    --quantMode GeneCounts --outFileNamePrefix aligned/mutated\r\n''')\r\n\r\n[3]\r\n# compare expression values\r\nR('''\r\ncontrol.count <- read.table('aligned/control.out.tab')\r\nmutated.count <- read.table('aligned/mutated.out.tab')\r\n# normalize, compare, output etc, ignored.\r\npdf('myfigure.pdf')\r\n# plot results\r\ndev.off()\r\n''')\r\n\r\n```\r\n\r\nYou can execute two shell scripts and a R script defined in this SoS script sequentially by running command\r\n\r\n```bash\r\nsos run myanalysis.sos\r\n```\r\n\r\nor simply\r\n\r\n```bash\r\nmyanalysis.sos\r\n```\r\n\r\nif you give `myanalyis.sos` executable permission (`chmod +x myanalysis.sos`). \r\n\r\n### Make the script work for other input files\r\nAfter a while, before you almost forgot about this analysis, you needed to analyze another pair of samples. You could copy ``myanalysis.sos`` to ``myanalysis2.sos``, change filenames and run it, but an easier way is to change your SoS file to accommodate other input files. This can be done by\r\ndefining a command line argument and passing files name to a **SoS variable**:\r\n\r\n```python\r\n#!/usr/bin/env sos-runner\r\n#fileformat=SOS1.0\r\n\r\n# This script aligns raw reads of a control and a mutated sample \r\n# to the reference genome and compare the expression values\r\n# of the samples at genes A, B and C.\r\n\r\n[parameters]\r\n# Two input files in .fasta formats. The first one for control sample\r\n# and the second one for mutated sample.\r\nfasta_files=['control.fasta', 'mutated.fasta']\r\n\r\n[1]\r\n# index reference genome\r\nrun('''\r\nSTAR --runMode genomeGenerate --genomeFastaFile human38.fasta --genomeDir STAR_index\r\n''')\r\n    \r\n[2]\r\n# align reads to the reference genome\r\nrun('''\r\nSTAR --genomeDir STAR_index --outSAMtype BAM SortedByCoordinate --readFilesIn ${fasta_files[0]}  \\\r\n    --quantMode GeneCounts --outFileNamePrefix aligned/control\r\nSTAR --genomeDir STAR_index --outSAMtype BAM SortedByCoordinate --readFilesIn ${fasta_files[1]}  \\\r\n    --quantMode GeneCounts --outFileNamePrefix aligned/mutated\r\n''')\r\n\r\n[3]\r\n# compare expression values\r\nR('''\r\ncontrol.count <- read.table('aligned/control.out.tab')\r\nmutated.count <- read.table('aligned/mutated.out.tab')\r\n# normalize, compare, output etc, ignored.\r\npdf('myfigure.pdf')\r\n# plot results\r\ndev.off()\r\n''')\r\n```\r\nA command line argument `fasta_files` is defined in the `[parameters]`\r\nsection of the script. With this definition, you can pass two filenames to\r\nvariable `fasta_files` from command line\r\n\r\n```bash\r\nsos run myanalysis.sos --fasta_files control1.fasta control2.fasta\r\n```\r\n\r\n`${fasta_files[0]}` and `${fasta_files[1]}` in command `STAR --genomeDir\r\n...` are replaced with their values before the commands are executed.\r\n\r\n### Ignore steps that do not need to be rerun\r\n\r\nAlthough the SoS script now accepts command line arguments, it is still no more than a compilation of scripts and you immediately realized that it is a waste of time to execute the first command each time. To solve this problem, you can convert the SoS script to a real workflow by telling SoS the input and output of each step:\r\n\r\n```python\r\n#!/usr/bin/env sos-runner\r\n#fileformat=SOS1.0\r\n\r\n# This script aligns raw reads of a control and a mutated sample \r\n# to the reference genome and compare the expression values\r\n# of the samples at genes A, B and C.\r\n\r\n[parameters]\r\n# Two input files in .fasta formats. The first one for control sample\r\n# and the second one for mutated sample.\r\nfasta_files=['control.fasta', 'mutated.fasta']\r\n\r\n[1]\r\n# create a index for reference genome\r\noutput: 'STAR_index/chrName.txt'\r\n\r\nrun('''\r\nSTAR --runMode genomeGenerate --genomeFastaFile human38.fasta --genomeDir STAR_index\r\n''')\r\n    \r\n[2]\r\n# align the reads to the reference genome\r\ninput:    fasta_files\r\ndepends:  'STAR_index/chrName.txt'\r\noutput:   ['aligned/control.out.tab', 'aligned/mutated.out.tab']\r\n\r\nrun('''\r\nSTAR --genomeDir STAR_index --outSAMtype BAM SortedByCoordinate  --readFilesIn ${input[0]}  \\\r\n    --quantMode GeneCounts --outFileNamePrefix aligned/control\r\nSTAR --genomeDir STAR_index --outSAMtype BAM SortedByCoordinate --readFilesIn ${input[1]}  \\\r\n    --quantMode GeneCounts --outFileNamePrefix aligned/mutated\r\n''')\r\n\r\n[3]\r\n# compare expression values\r\noutput: 'myfigure.pdf'\r\n\r\nR('''\r\ncontrol.count <- read.table('${input[0]}')\r\nmutated.count <- read.table('${input[1]}')\r\n# normalize, compare, output etc, ignored.\r\npdf('myfigure.pdf')\r\n# plot results\r\ndev.off()\r\n''')\r\n\r\n```\r\n\r\nHere we\r\n \r\n- Use **output directive** to specify the expected output of all steps2.\r\n- Use **input directive** to specify the input of step 2. Step 1 by default has no input and step 3 by default has the output from its previous step.\r\n- Use **depends directive** to let step 2 depend on the output of step 1.\r\n- Use `${input[0]}` and `${input[1]}` in step 2 and 3 because these steps now have properly-defined `input`.\r\n\r\nWith such information, when you run the same command\r\n\r\n```bash\r\nsos run myanalysis.sos --input control1.fasta control2.fasta\r\n```\r\n\r\nSoS will ignore step 1 if this step has been run with output `STAR_index/chrName.txt`. The same happens to step 2 and 3 so all steps will be ignored if you run the script repeatedly with the same input and processing scripts. SoS uses **runtime signature** for each step and will re-run the step if and only if the content or filename of input, output files or the processing scripts are changed.\r\n\r\n### Execute steps in parallel\r\nSoS allows execution of workflows in parallel. Although the three steps of this example have to be\r\nexecuted sequentially, the second step runs the `STAR` command twice on two input files, and can\r\nbe executed in parallel. You can tell this to SoS by modifying the script as follows\r\n\r\n```python\r\n#!/usr/bin/env sos-runner\r\n#fileformat=SOS1.0\r\n\r\n# This script aligns raw reads of a control and a mutated sample \r\n# to the reference genome and compare the expression values\r\n# of the samples at genes A, B and C.\r\n\r\n[parameters]\r\n# Two input files in .fasta formats. The first one for control sample\r\n# and the second one for mutated sample.\r\nfasta_files=['control.fasta', 'mutated.fasta']\r\n\r\n[1]\r\n# create a index for reference genome\r\noutput: 'STAR_index/chrName.txt'\r\n\r\nrun('''\r\nSTAR --runMode genomeGenerate --genomeFastaFile human38.fasta --genomeDir STAR_index\r\n''')\r\n\r\n    \r\n[2]\r\n# align the reads to the reference genome\r\nsample_type=['control', 'mutated']\r\n\r\ninput:    fasta_files, group_by='single', labels='sample_type'\r\ndepends:  'STAR_index/chrName.txt'\r\noutput:   ['aligned/control.out.tab', 'aligned/mutated.out.tab']\r\n\r\nrun('''\r\nSTAR --genomeDir STAR_index --outSAMtype BAM SortedByCoordinate  --readFilesIn ${input}  \\\r\n    --quantMode GeneCounts --outFileNamePrefix aligned/${_sample_type}\r\n''')\r\n\r\n[3]\r\n# compare expression values\r\noutput: 'myfigure.pdf'\r\n\r\nR('''\r\ncontrol.count <- read.table('${input[0]}')\r\nmutated.count <- read.table('${input[1]}')\r\n# normalize, compare, output etc, ignored.\r\npdf('myfigure.pdf')\r\n# plot results\r\ndev.off()\r\n''')\r\n\r\n```\r\n\r\nHere we \r\n\r\n1. Use option `group_by='single'` to pass input one by one to action. The action will be executed twice with `input` set to the first and second input file respectively.\r\n2. Define a variable `sample_type` and mark it as the labels for input files (option `labels`). This will generate a variable `_sample_type` for each input file so `_sample_type` will be `control` for the first input file, and `mutated` for the second.\r\n\r\nNow, if you execute the script with option `-j 2` (2 concurrent processes),\r\n\r\n```bash\r\nsos run myanalysis.sos --input control1.fasta control2.fasta -j 2\r\n```\r\n\r\nthe second step would be run in parallel.\r\n\r\nWe have showed you four versions of the same SoS script, each using more features of SoS. This actually demonstrates one of the advantages of the SoS system, namely you can start using SoS in minutes without knowing any of its advanced features, and gradually improve your script if needed.\r\n\r\n## Unique features and limitations\r\n\r\nThe biggest difference between SoS and GNU make style workflow systems such as\r\n[snakemake](https://bitbucket.org/johanneskoester/snakemake) is that **SoS is\r\ninput driven instead of output driven**. SoS will execute all steps in a\r\nworkflow even if some steps do not produce any output (but can for example\r\ncheck input files and stop the execution if an error occurs). It can also\r\nexecute steps conditionally, repeatedly, or generate different outputs with\r\ndifferent input files. In contrast, make-style systems focus on output files\r\nand ignore steps that are irrelevant to the final outcome.\r\n\r\nCompared to XML or system-specific workflow lanaguges such as\r\n[CWL](http://common-workflow-language.github.io/), **SoS emphasizes greatly\r\non readability**. The workflow steps are logically arranged (although actual\r\nexecution order might differ) and contain explict commands and scripts.\r\nMost comments are significant and provide usable information in output such\r\nas `sos show script`. This makes it easy for readers to read the workflow\r\nand modify it if needed. This can be very useful for fields such as\r\nbioinformatics where workflows need to be frequently updated to accomodate\r\nnew tools, reference genomes, and annotations.\r\n\r\nSoS is essentially a tool to compose and execute commands and scripts. It\r\nuses workflow variables (and their derived forms) and string substitution\r\nto create scripts (from user-provided templates) and execute them with\r\ntheir own interpreters. Therefore, \r\n\r\n* SoS only supports command line tools. There is no plan to extend it for interactive or GUI usages.\r\n* SoS does not understand the underlying tools and scripts and have no\r\ncontrol over exactly what they do. Incorrect use of workflow variables\r\nmight result in non-executable scripts.\r\n* SoS workflow system is largely file based (although you can check environments such as environmental variables through SoS variables). It does not support features such as piping between steps (neither do systems such as CWL support it).\r\n\r\n## Summary\r\n\r\nThe above example only shows a small fraction of what SoS can offer, but should be enough to demonstrate the unique features of SoS. Compared to maintaining multiple scripts or using more specifilized workflow systems such as [YAWL](http://www.yawlfoundation.org/), [CWL](http://common-workflow-language.github.io/), and [Galaxy](https://galaxyproject.org/),\r\n\r\n* **SoS offers a way to organize your scripts in a single file**, which makes it easy to execute and maintain. You can include small and freqently changed commands and scripts in SoS and keep large and stable scripts as separate scripts.\r\n* **SoS scripts are human readable and writable**. In comparison, it would take a lot of time and practice to learn its syntax write a [CWL](http://common-workflow-language.github.io/) workflow (see [this CWL tutorial](https://github.com/common-workflow-language/workflows/wiki/Tutorial-DRAFT2) for an example). \r\n* **SoS help you execute your scripts with advanced workflow features**. The workflow features of SoS is easy to use yet very powerful in helping you execute your pipelines efficiently not only locally, but also on cluster and cloud systems.\r\n\r\nIf you are afraid of being tied to a new workflow tool, rest assured that SoS allows you to **[export SoS scripts](doc/commandline.md#subcommand-export)** to a series of scripts called by a master bash (or windows .bat) script. This would allow you to execute your workflow in an environement without SoS installed.\r\n\r\nPlease refer to the SoS documentation for more details and feel free to [contact me](mailto:ben.bob@gmail.com) if you have any comment on this project.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}